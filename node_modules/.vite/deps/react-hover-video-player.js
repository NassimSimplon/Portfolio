import {
  require_react
} from "./chunk-ZOIWZPCO.js";
import {
  __toESM
} from "./chunk-DFKQJ226.js";

// node_modules/react-hover-video-player/dist/index.esm.js
var import_react = __toESM(require_react());
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function useSetAdditionalAttributesOnVideo(videoRef, muted, volume, disableRemotePlayback, disablePictureInPicture) {
  (0, import_react.useEffect)(function() {
    var videoElement = videoRef.current;
    videoElement.muted = muted;
    videoElement.volume = volume;
  }, [videoRef, muted, volume]);
  (0, import_react.useEffect)(function() {
    var videoElement = videoRef.current;
    videoElement.disableRemotePlayback = disableRemotePlayback;
    videoElement.disablePictureInPicture = disablePictureInPicture;
  }, [videoRef, disablePictureInPicture, disableRemotePlayback]);
}
function useFormatVideoSrc(videoSrc, playbackRangeStart, playbackRangeEnd) {
  var previousVideoSrc = (0, import_react.useRef)(null);
  var previousFormattedVideoSources = (0, import_react.useRef)(null);
  if (previousVideoSrc.current !== null && videoSrc === previousVideoSrc.current) {
    return previousFormattedVideoSources.current;
  }
  previousVideoSrc.current = videoSrc;
  var formattedVideoSources = [];
  if (videoSrc == null) {
    console.error("Error: 'videoSrc' prop is required for HoverVideoPlayer component");
  } else {
    var rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc];
    for (var i = 0, numSources = rawVideoSources.length; i < numSources; i += 1) {
      var source = rawVideoSources[i];
      var hasPlaybackRangeStart = playbackRangeStart !== null;
      var hasPlaybackRangeEnd = playbackRangeEnd !== null;
      var playbackRangeMediaFragmentIdentifier = hasPlaybackRangeStart || hasPlaybackRangeEnd ? (
        // If we have a playback range defined, construct a #t media fragment identifier string
        // This identifier follows the format `#t=[starttime][,endtime]` and will tell the browser to only load the video file
        // within this defined time range.
        // This helps save us from loading some unneeded data when we only need whatever is within the playback range!
        "#t=".concat(hasPlaybackRangeStart ? playbackRangeStart : "").concat(hasPlaybackRangeEnd ? ",".concat(playbackRangeEnd) : "")
      ) : "";
      if (typeof source === "string") {
        formattedVideoSources.push({
          src: "".concat(source).concat(playbackRangeMediaFragmentIdentifier)
        });
      } else if (source && source.src) {
        formattedVideoSources.push({
          src: "".concat(source.src).concat(playbackRangeMediaFragmentIdentifier),
          type: source.type
        });
      } else {
        console.error("Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':", source);
      }
    }
  }
  if (JSON.stringify(formattedVideoSources) === JSON.stringify(previousFormattedVideoSources.current)) {
    return previousFormattedVideoSources.current;
  }
  previousFormattedVideoSources.current = formattedVideoSources;
  return formattedVideoSources;
}
function useFormatVideoCaptions(videoCaptions) {
  return (0, import_react.useMemo)(function() {
    var formattedVideoCaptions = [];
    if (videoCaptions != null) {
      var rawVideoCaptions = Array.isArray(videoCaptions) ? videoCaptions : [videoCaptions];
      for (var i = 0, numCaptions = rawVideoCaptions.length; i < numCaptions; i += 1) {
        var captions = rawVideoCaptions[i];
        if (captions && captions.src) {
          formattedVideoCaptions.push({
            src: captions.src,
            srcLang: captions.srcLang,
            label: captions.label,
            kind: captions.kind || "captions",
            default: Boolean(captions.default)
          });
        } else {
          console.error("Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'", captions);
        }
      }
    }
    return formattedVideoCaptions;
  }, [videoCaptions]);
}
var getElementFromHoverTarget = function(hoverTarget) {
  if (typeof hoverTarget === "function") {
    return hoverTarget();
  } else if (hoverTarget instanceof Node) {
    return hoverTarget;
  } else if (hoverTarget && hoverTarget.hasOwnProperty("current")) {
    return hoverTarget.current;
  } else {
    console.error("HoverVideoPlayer was unable to get a usable hover target element. Please check your usage of the `hoverTarget` prop.");
  }
};
function useHoverTargetElement(hoverTarget) {
  var _a = (0, import_react.useState)(null), hoverTargetElement = _a[0], setHoverTargetElement = _a[1];
  (0, import_react.useEffect)(function() {
    setHoverTargetElement(getElementFromHoverTarget(hoverTarget));
  }, [hoverTarget]);
  return hoverTargetElement;
}
function useManageHoverEvents(hoverTargetElement, focused, disableDefaultEventHandling, onHoverStartCallback, onHoverEndCallback) {
  var onHoverStartCallbackRef = (0, import_react.useRef)();
  onHoverStartCallbackRef.current = onHoverStartCallback;
  var onHoverEndCallbackRef = (0, import_react.useRef)();
  onHoverEndCallbackRef.current = onHoverEndCallback;
  (0, import_react.useEffect)(function() {
    if (disableDefaultEventHandling || !hoverTargetElement)
      return void 0;
    var onHoverStart = function() {
      hoverTargetElement.dispatchEvent(new Event("hvp:hoverStart"));
      if (onHoverStartCallbackRef.current)
        onHoverStartCallbackRef.current();
    };
    var onHoverEnd = function() {
      hoverTargetElement.dispatchEvent(new Event("hvp:hoverEnd"));
      if (onHoverEndCallbackRef.current)
        onHoverEndCallbackRef.current();
    };
    hoverTargetElement.addEventListener("mouseenter", onHoverStart);
    hoverTargetElement.addEventListener("mouseleave", onHoverEnd);
    hoverTargetElement.addEventListener("focus", onHoverStart);
    hoverTargetElement.addEventListener("blur", onHoverEnd);
    var touchStartListenerOptions = { passive: true };
    hoverTargetElement.addEventListener("touchstart", onHoverStart, touchStartListenerOptions);
    var onWindowTouchStart = function(event) {
      if (!(event.target instanceof Node) || !hoverTargetElement.contains(event.target)) {
        onHoverEnd();
      }
    };
    window.addEventListener("touchstart", onWindowTouchStart, touchStartListenerOptions);
    return function() {
      hoverTargetElement.removeEventListener("mouseenter", onHoverStart);
      hoverTargetElement.removeEventListener("mouseleave", onHoverEnd);
      hoverTargetElement.removeEventListener("focus", onHoverStart);
      hoverTargetElement.removeEventListener("blur", onHoverEnd);
      hoverTargetElement.removeEventListener("touchstart", onHoverStart);
      window.removeEventListener("touchstart", onWindowTouchStart);
    };
  }, [disableDefaultEventHandling, hoverTargetElement]);
  var previousFocusedRef = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(function() {
    if (!hoverTargetElement)
      return;
    if (previousFocusedRef.current !== focused) {
      previousFocusedRef.current = focused;
      if (focused) {
        hoverTargetElement.dispatchEvent(new Event("hvp:hoverStart"));
      } else {
        hoverTargetElement.dispatchEvent(new Event("hvp:hoverEnd"));
      }
    }
  }, [hoverTargetElement, focused]);
}
function isVideoElementPaused(videoElement) {
  return videoElement.paused || videoElement.ended;
}
function isVideoElementLoading(videoElement) {
  return !isVideoElementPaused(videoElement) && videoElement.readyState < videoElement.HAVE_FUTURE_DATA;
}
function isVideoElementPlaying(videoElement) {
  return !isVideoElementPaused(videoElement) && !isVideoElementLoading(videoElement);
}
var expandToFillContainerStyle = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  bottom: 0,
  left: 0,
  right: 0
};
var containerMatchContentDimensionsStyle = {
  display: "inline-block"
};
var containerSizingStyles = {
  video: containerMatchContentDimensionsStyle,
  overlay: containerMatchContentDimensionsStyle,
  container: null,
  manual: null
};
var pausedOverlayWrapperSizingStyles = {
  // Sizing should be based on the video element, so make the overlay
  // expand to cover the player's container element
  video: expandToFillContainerStyle,
  // Sizing should be based on the paused overlay, so set position: relative
  // to make it occupy space in the document flow
  overlay: {
    position: "relative"
  },
  // Sizing should be based on the player's container element, so make the overlay
  // expand to cover it
  container: expandToFillContainerStyle,
  // Don't apply any preset styling to the overlay
  manual: null
};
var videoSizingStyles = {
  // Sizing should be based on the video element, so set display: block
  // to make sure it occupies space in the document flow
  video: {
    display: "block",
    // Ensure the video is sized relative to the container's width
    // rather than the video asset's native width
    width: "100%"
  },
  // Make the video element expand to cover the container if we're sizing
  // based on the overlay or container
  overlay: expandToFillContainerStyle,
  container: expandToFillContainerStyle,
  // Don't apply any preset styling to the video
  manual: null
};
function HoverVideoPlayer(_a) {
  var videoSrc = _a.videoSrc, _b = _a.videoCaptions, videoCaptions = _b === void 0 ? null : _b, _c = _a.focused, focused = _c === void 0 ? false : _c, _d = _a.disableDefaultEventHandling, disableDefaultEventHandling = _d === void 0 ? false : _d, _e = _a.hoverTarget, hoverTarget = _e === void 0 ? null : _e, _f = _a.onHoverStart, onHoverStart = _f === void 0 ? null : _f, _g = _a.onHoverEnd, onHoverEnd = _g === void 0 ? null : _g, _h = _a.hoverOverlay, hoverOverlay = _h === void 0 ? null : _h, _j = _a.pausedOverlay, pausedOverlay = _j === void 0 ? null : _j, _k = _a.loadingOverlay, loadingOverlay = _k === void 0 ? null : _k, _l = _a.loadingStateTimeout, loadingStateTimeout = _l === void 0 ? 200 : _l, _m = _a.overlayTransitionDuration, overlayTransitionDuration = _m === void 0 ? 400 : _m, _o = _a.playbackStartDelay, playbackStartDelay = _o === void 0 ? 0 : _o, _p = _a.restartOnPaused, restartOnPaused = _p === void 0 ? false : _p, _q = _a.unloadVideoOnPaused, unloadVideoOnPaused = _q === void 0 ? false : _q, _r = _a.playbackRangeStart, playbackRangeStart = _r === void 0 ? null : _r, _s = _a.playbackRangeEnd, playbackRangeEnd = _s === void 0 ? null : _s, _t = _a.muted, muted = _t === void 0 ? true : _t, _u = _a.volume, volume = _u === void 0 ? 1 : _u, _v = _a.loop, loop = _v === void 0 ? true : _v, _w = _a.preload, preload = _w === void 0 ? null : _w, _x = _a.crossOrigin, crossOrigin = _x === void 0 ? null : _x, _y = _a.controls, controls = _y === void 0 ? false : _y, _z = _a.controlsList, controlsList = _z === void 0 ? null : _z, _0 = _a.disableRemotePlayback, disableRemotePlayback = _0 === void 0 ? true : _0, _1 = _a.disablePictureInPicture, disablePictureInPicture = _1 === void 0 ? true : _1, _2 = _a.style, style = _2 === void 0 ? null : _2, _3 = _a.hoverOverlayWrapperClassName, hoverOverlayWrapperClassName = _3 === void 0 ? null : _3, _4 = _a.hoverOverlayWrapperStyle, hoverOverlayWrapperStyle = _4 === void 0 ? null : _4, _5 = _a.pausedOverlayWrapperClassName, pausedOverlayWrapperClassName = _5 === void 0 ? null : _5, _6 = _a.pausedOverlayWrapperStyle, pausedOverlayWrapperStyle = _6 === void 0 ? null : _6, _7 = _a.loadingOverlayWrapperClassName, loadingOverlayWrapperClassName = _7 === void 0 ? null : _7, _8 = _a.loadingOverlayWrapperStyle, loadingOverlayWrapperStyle = _8 === void 0 ? null : _8, _9 = _a.videoId, videoId = _9 === void 0 ? null : _9, _10 = _a.videoClassName, videoClassName = _10 === void 0 ? null : _10, _11 = _a.videoRef, forwardedVideoRef = _11 === void 0 ? null : _11, _12 = _a.videoStyle, videoStyle = _12 === void 0 ? null : _12, _13 = _a.sizingMode, sizingMode = _13 === void 0 ? "video" : _13, _14 = _a.shouldSuppressPlaybackInterruptedErrors, shouldSuppressPlaybackInterruptedErrors = _14 === void 0 ? true : _14, spreadableProps = __rest(_a, ["videoSrc", "videoCaptions", "focused", "disableDefaultEventHandling", "hoverTarget", "onHoverStart", "onHoverEnd", "hoverOverlay", "pausedOverlay", "loadingOverlay", "loadingStateTimeout", "overlayTransitionDuration", "playbackStartDelay", "restartOnPaused", "unloadVideoOnPaused", "playbackRangeStart", "playbackRangeEnd", "muted", "volume", "loop", "preload", "crossOrigin", "controls", "controlsList", "disableRemotePlayback", "disablePictureInPicture", "style", "hoverOverlayWrapperClassName", "hoverOverlayWrapperStyle", "pausedOverlayWrapperClassName", "pausedOverlayWrapperStyle", "loadingOverlayWrapperClassName", "loadingOverlayWrapperStyle", "videoId", "videoClassName", "videoRef", "videoStyle", "sizingMode", "shouldSuppressPlaybackInterruptedErrors"]);
  var containerRef = (0, import_react.useRef)(null);
  var videoRef = (0, import_react.useRef)(null);
  (0, import_react.useImperativeHandle)(forwardedVideoRef, function() {
    return videoRef.current;
  });
  useSetAdditionalAttributesOnVideo(videoRef, muted, volume, disableRemotePlayback, disablePictureInPicture);
  var hoverTargetElement = useHoverTargetElement(hoverTarget || containerRef);
  var nextVideoStartTimeRef = (0, import_react.useRef)(null);
  var formattedVideoCaptions = useFormatVideoCaptions(videoCaptions);
  var formattedVideoSources = useFormatVideoSrc(videoSrc, playbackRangeStart, playbackRangeEnd);
  var previousFormattedVideoSourcesRef = (0, import_react.useRef)(formattedVideoSources);
  var attemptToPlayVideoRef = (0, import_react.useRef)();
  attemptToPlayVideoRef.current = function() {
    var videoElement = videoRef.current;
    if (nextVideoStartTimeRef.current !== null) {
      videoElement.currentTime = nextVideoStartTimeRef.current;
    }
    videoElement.play().catch(function(error) {
      if (shouldSuppressPlaybackInterruptedErrors && error.name === "AbortError") {
        return;
      }
      if (!videoElement.muted && error.name === "NotAllowedError") {
        console.warn("HoverVideoPlayer: Playback with sound was blocked by the browser. Attempting to play again with the video muted; audio will be restored if the user clicks on the page.");
        videoElement.muted = true;
        videoElement.play();
        var onClickDocument_1 = function() {
          videoElement.muted = false;
          document.removeEventListener("click", onClickDocument_1);
        };
        document.addEventListener("click", onClickDocument_1);
      } else {
        console.error("HoverVideoPlayer: ".concat(error.message));
      }
    });
  };
  var attemptToPauseVideoRef = (0, import_react.useRef)();
  attemptToPauseVideoRef.current = function() {
    var videoElement = videoRef.current;
    videoElement.pause();
    if (restartOnPaused) {
      videoElement.currentTime = playbackRangeStart || 0;
    }
    nextVideoStartTimeRef.current = videoElement.currentTime;
    setIsPlaying(false);
  };
  var _15 = (0, import_react.useState)(false), isPlaying = _15[0], setIsPlaying = _15[1];
  var _16 = (0, import_react.useState)(false), isHovering = _16[0], setIsHovering = _16[1];
  (0, import_react.useEffect)(function() {
    if (!isPlaying) {
      var shouldReloadVideoSources = previousFormattedVideoSourcesRef.current !== formattedVideoSources;
      if (shouldReloadVideoSources) {
        previousFormattedVideoSourcesRef.current = formattedVideoSources;
        var videoElement = videoRef.current;
        videoElement.load();
        nextVideoStartTimeRef.current = playbackRangeStart || 0;
      }
    }
  }, [formattedVideoSources, isPlaying, playbackRangeStart]);
  var hasPausedOverlay = Boolean(pausedOverlay);
  var hasHoverOverlay = Boolean(hoverOverlay);
  var shouldWaitForOverlayTransitionBeforePausing = hasPausedOverlay || hasHoverOverlay;
  (0, import_react.useEffect)(function() {
    if (!hoverTargetElement)
      return void 0;
    var playbackStartTimeout = null;
    var pauseTimeout = null;
    var cancelTimeouts = function() {
      window.clearTimeout(playbackStartTimeout);
      window.clearTimeout(pauseTimeout);
    };
    var attemptToPlayVideoOnHover = function() {
      cancelTimeouts();
      setIsHovering(true);
      if (isVideoElementPaused(videoRef.current)) {
        if (playbackStartDelay) {
          playbackStartTimeout = window.setTimeout(function() {
            return attemptToPlayVideoRef.current();
          }, playbackStartDelay);
        } else {
          attemptToPlayVideoRef.current();
        }
      }
    };
    var attemptToPauseVideoOnHoverEnd = function() {
      cancelTimeouts();
      setIsHovering(false);
      if (
        // We only need to delay a pause attempt if the video is currently playing
        isVideoElementPlaying(videoRef.current) && shouldWaitForOverlayTransitionBeforePausing
      ) {
        pauseTimeout = window.setTimeout(function() {
          return attemptToPauseVideoRef.current();
        }, overlayTransitionDuration);
      } else {
        attemptToPauseVideoRef.current();
      }
    };
    hoverTargetElement.addEventListener("hvp:hoverStart", attemptToPlayVideoOnHover);
    hoverTargetElement.addEventListener("hvp:hoverEnd", attemptToPauseVideoOnHoverEnd);
    return function() {
      hoverTargetElement.removeEventListener("hvp:hoverStart", attemptToPlayVideoOnHover);
      hoverTargetElement.removeEventListener("hvp:hoverEnd", attemptToPauseVideoOnHoverEnd);
      cancelTimeouts();
    };
  }, [
    hoverTargetElement,
    overlayTransitionDuration,
    playbackStartDelay,
    shouldWaitForOverlayTransitionBeforePausing
  ]);
  useManageHoverEvents(hoverTargetElement, focused, disableDefaultEventHandling, onHoverStart, onHoverEnd);
  var hasLoadingOverlay = Boolean(loadingOverlay);
  var shouldUnloadVideo = unloadVideoOnPaused && !isHovering && !isPlaying;
  (0, import_react.useEffect)(function() {
    if (shouldUnloadVideo) {
      var videoElement = videoRef.current;
      videoElement.load();
    }
  }, [shouldUnloadVideo]);
  var shouldShowLoadingOverlay = isHovering && !isPlaying;
  var shouldShowPausedOverlay = !isHovering || isHovering && !isPlaying;
  var isUsingPlaybackRange = playbackRangeStart !== null || playbackRangeEnd !== null;
  return import_react.default.createElement(
    "div",
    __assign({ "data-testid": "hover-video-player-container", ref: containerRef, style: __assign(__assign(__assign({}, containerSizingStyles[sizingMode]), { position: "relative" }), style) }, spreadableProps),
    hasPausedOverlay ? import_react.default.createElement("div", { style: __assign(__assign(__assign({}, pausedOverlayWrapperSizingStyles[sizingMode]), {
      zIndex: 1,
      opacity: shouldShowPausedOverlay ? 1 : 0,
      transition: "opacity ".concat(overlayTransitionDuration, "ms"),
      // Disable pointer events on the paused overlay when it's hidden
      pointerEvents: shouldShowPausedOverlay ? "auto" : "none"
    }), pausedOverlayWrapperStyle), className: pausedOverlayWrapperClassName, "data-testid": "paused-overlay-wrapper" }, pausedOverlay) : null,
    hasLoadingOverlay ? import_react.default.createElement("div", { style: __assign(__assign(__assign({}, expandToFillContainerStyle), {
      zIndex: 2,
      opacity: shouldShowLoadingOverlay ? 1 : 0,
      transition: "opacity ".concat(overlayTransitionDuration, "ms ").concat(shouldShowLoadingOverlay ? loadingStateTimeout : 0, "ms"),
      // Disable pointer events on the loading overlay when it's hidden
      pointerEvents: shouldShowLoadingOverlay ? "auto" : "none"
    }), loadingOverlayWrapperStyle), className: loadingOverlayWrapperClassName, "data-testid": "loading-overlay-wrapper" }, loadingOverlay) : null,
    hasHoverOverlay ? import_react.default.createElement("div", { style: __assign(__assign(__assign({}, expandToFillContainerStyle), {
      zIndex: 3,
      // Show the hover overlay when the player is hovered/playing
      opacity: isHovering ? 1 : 0,
      transition: "opacity ".concat(overlayTransitionDuration, "ms"),
      // Disable pointer events on the hover overlay when it's hidden
      pointerEvents: isHovering ? "auto" : "none"
    }), hoverOverlayWrapperStyle), className: hoverOverlayWrapperClassName, "data-testid": "hover-overlay-wrapper" }, hoverOverlay) : null,
    import_react.default.createElement(
      "video",
      {
        // If a playback range is set, the loop attribute will not work correctly so there's no point in setting it here;
        // in that case, we will manually implement this behavior
        loop: isUsingPlaybackRange ? false : loop,
        playsInline: true,
        preload,
        crossOrigin,
        ref: videoRef,
        style: __assign(__assign(__assign({}, videoSizingStyles[sizingMode]), { objectFit: "cover" }), videoStyle),
        controls,
        controlsList,
        className: videoClassName,
        id: videoId,
        "data-testid": "video-element",
        onPlaying: function() {
          setIsPlaying(true);
        },
        onTimeUpdate: (
          // If there's a playback range set, the traditional `loop` video prop won't work correctly so
          // we'll need watch the video's time as it plays and manually keep it within the bounds of the range
          isUsingPlaybackRange ? function() {
            var videoElement = videoRef.current;
            var maxVideoTime = playbackRangeEnd || videoElement.duration;
            var minVideoTime = playbackRangeStart || 0;
            var currentTime = videoElement.currentTime;
            if (loop && currentTime >= maxVideoTime) {
              var startTime = playbackRangeStart || 0;
              videoElement.currentTime = startTime;
              if (isHovering && isVideoElementPaused(videoElement)) {
                videoElement.play();
              }
            } else if (currentTime > maxVideoTime) {
              videoElement.pause();
              videoElement.currentTime = maxVideoTime;
            } else if (currentTime < minVideoTime) {
              videoElement.currentTime = minVideoTime;
            }
          } : null
        )
      },
      !shouldUnloadVideo && // Only render sources for the video if it is not unloaded
      formattedVideoSources.map(function(_a2) {
        var src = _a2.src, type = _a2.type;
        return import_react.default.createElement("source", { key: src, src, type });
      }),
      formattedVideoCaptions.map(function(_a2) {
        var src = _a2.src, srcLang = _a2.srcLang, label = _a2.label, kind = _a2.kind, isDefault = _a2.default;
        return import_react.default.createElement("track", { key: src, kind, src, srcLang, label, default: isDefault });
      })
    )
  );
}
export {
  HoverVideoPlayer as default
};
/*! Bundled license information:

react-hover-video-player/dist/index.esm.js:
  (**
   * @component HoverVideoPlayer
   * @license MIT
   *
   * @param {HoverVideoPlayerProps} props
   *)
*/
//# sourceMappingURL=react-hover-video-player.js.map
